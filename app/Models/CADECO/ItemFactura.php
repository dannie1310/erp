<?php
/**
 * Created by PhpStorm.
 * User: EMartinez
 * Date: 03/01/2020
 * Time: 11:05 AM
 */

namespace App\Models\CADECO;


class ItemFactura extends Item
{
    protected static function boot()
    {
        parent::boot(); // TODO: Change the autogenerated stub

        self::addGlobalScope(function ($query) {
            return $query->whereHas('factura')->where('estado', '>=', 0);
        });
    }

    public function factura()
    {
        return $this->belongsTo(Factura::class, 'id_transaccion', 'id_transaccion');
    }

    public function inventario()
    {
        return $this->belongsTo(Inventario::class, 'id_item', 'id_item');
    }

    public function material()
    {
        return $this->belongsTo(Material::class, 'id_material');
    }

    public function movimiento()
    {
        return $this->belongsTo(Movimiento::class, 'id_item', 'id_item');
    }

    public function itemAntecedente()
    {
        return $this->belongsTo(Item::class, 'item_antecedente', 'id_item');
    }

    public function antecedente()
    {
        return $this->belongsTo(Transaccion::class, 'id_antecedente', 'id_transaccion');
    }

    public function getProporcionItemAttribute()
    {
        return $this->importe / $this->factura->monto;
    }

    /**
     * Este método implementa la lógica actualización de control de obra del procedimiento almacenado sp_aplicar_pagos
     * y se detona al registrar una orden de pago
     */
    public function actualizaControlObra(OrdenPago $orden_pago)
    {
        $importe = round($orden_pago->monto * -1 * $this->proporcion_item, 2);
        $tipo_cambio = $this->factura->tipo_cambio;
        /**
         * La lógica de actualización del control de obra es distinta dependiendo del tipo de antecedente del item de factura
         */
        switch ($this->numero) {
            case 0:
                ItemEntradaAlmacen::find($this->item_antecedente)->actualizaControlObra($importe, $tipo_cambio);
                break;
            case 1:
                switch ($this->antecedente->tipo_transaccion) {
                    case 51:
                        Subcontrato::find($this->id_antecedente)->actualizaControlObra($this, $orden_pago);
                        break;
                    case 52:
                        Estimacion::find($this->id_antecedente)->actualizaControlObra($this, $orden_pago);
                        break;
                }
                break;
            case 2:
                if ($this->antecedente->opciones == 1) {
                    ItemOrdenCompra::find($this->item_antecedente)->actualizaControlObra($this, $orden_pago);
                } else {
                    ItemOrdenRenta::find($this->item_antecedente)->actualizaControlObra($this, $orden_pago);
                }
                break;
            case 3:
                ItemEntradaMaquinaria::find($this->item_antecedente)->actualizaControlObra($this, $orden_pago);
                break;
            case 4:
                if ($this->antecedente->tipo_transaccion == 99) {
                    ListaRaya::find($this->id_antecedente)->actualizaControlObra($this, $orden_pago);
                } else {
                    Prestacion::find($this->id_antecedente)->actualizaControlObra($this, $orden_pago);
                }
                break;
            case 7:
                if ($this->inventario) {
                    $this->inventario->monto_pagado = $this->inventario->monto_pagado +
                        round($importe * $this->factura->tipo_cambio, 2);
                    $this->inventario->monto_pagado->save();
                    $this->inventario->distribuirPagoInventarios();

                } elseif ($this->movimiento) {
                    $this->movimiento->monto_pagado = $this->movimiento->monto_pagado +
                        round($importe * $tipo_cambio, 2);
                    $this->movimiento->monto_pagado->save();
                } else {
                    abort(500, "No se encontró la entidad de de control de obra relacionada con el item de la factura de varios");
                }
                break;
        }

        $saldo = (($this->saldo - $importe) > 0.01) ? round(($this->saldo - $importe), 2) : 0;
        $this->autorizado = $this->autorizado - $importe;
        $this->saldo = $saldo;
        $this->save();
        $this->registraItemOrdenPago($orden_pago);

    }

    private function registraItemOrdenPago(OrdenPago $orden_pago)
    {
        $importe = round($orden_pago->monto * -1 * $this->proporcion_item, 2);
        $datos = [
            'id_transaccion' => $orden_pago->id_transaccion,
            'item_antecedente' => $this->id_item,
            'importe' => $importe,
        ];
        ItemOrdenPago::create($datos);
    }
}